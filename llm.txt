#File ./conftest.py:
import sys
from pathlib import Path

# Add the src directory to the Python path
src_path = Path(__file__).parent / "src"
sys.path.insert(0, str(src_path))







#File ./src/autocoder/error_handler.py:
import traceback
import logging

logger = logging.getLogger(__name__)


class ErrorHandler:
    def __init__(self):
        pass

    def handle_error(self, error):
        if isinstance(error, str):
            # If error is already a string (e.g., from TestRunner)
            error_message = error
        else:
            # If error is an exception
            error_message = str(error)

        logger.error(f"An error occurred: {error_message}")

        # Get the full traceback
        tb = traceback.extract_tb(error.__traceback__) if hasattr(error, '__traceback__') else []

        # Format the error report
        error_report = f"Error: {error_message}\n\n"
        error_report += "Traceback:\n"
        for frame in tb:
            error_report += f"  File '{frame.filename}', line {frame.lineno}, in {frame.name}\n"
            error_report += f"    {frame.line}\n"

        # Provide some general advice
        error_report += "\nSuggestions:\n"
        error_report += "1. Check the traceback above to identify where the error occurred.\n"
        error_report += "2. Review any recent changes to the affected files.\n"
        error_report += "3. Ensure all necessary dependencies are installed and up to date.\n"
        error_report += "4. If the error persists, consider reverting recent changes or seeking further assistance.\n"

        return error_report

    def log_error(self, error):
        logger.error(f"An error occurred: {str(error)}")
        logger.error(traceback.format_exc())







#File ./src/autocoder/task_interpreter.py:
import re
from enum import Enum


class TaskType(Enum):
    ADD_FEATURE = "add_feature"
    FIX_BUG = "fix_bug"
    REFACTOR = "refactor"
    OPTIMIZE = "optimize"
    TEST = "test"
    DOCUMENT = "document"
    UNKNOWN = "unknown"


class TaskInterpreter:
    def __init__(self):
        self.task_type_keywords = {
            TaskType.ADD_FEATURE: ["add", "create", "implement", "new feature"],
            TaskType.FIX_BUG: ["fix", "bug", "issue", "problem", "error"],
            TaskType.REFACTOR: ["refactor", "restructure", "reorganize"],
            TaskType.OPTIMIZE: ["optimize", "improve performance", "speed up"],
            TaskType.TEST: ["test", "unit test", "integration test"],
            TaskType.DOCUMENT: ["document", "add comments", "explain"]
        }

    def interpret_task(self, task_description):
        task_type = self._determine_task_type(task_description)
        affected_files = self._identify_affected_files(task_description)
        subtasks = self._break_into_subtasks(task_description)

        return {
            "original_description": task_description,
            "task_type": task_type.value,
            "affected_files": affected_files,
            "subtasks": subtasks
        }

    def _determine_task_type(self, task_description):
        task_description_lower = task_description.lower()
        for task_type, keywords in self.task_type_keywords.items():
            if any(keyword in task_description_lower for keyword in keywords):
                return task_type
        return TaskType.UNKNOWN

    def _identify_affected_files(self, task_description):
        # Simple regex to find file names (adjust as needed)
        file_pattern = r'\b[\w-]+\.(py|js|html|css|md)\b'
        return list(set(re.findall(file_pattern, task_description)))

    def _break_into_subtasks(self, task_description):
        # Simple subtask breakdown (can be improved with NLP techniques)
        subtasks = task_description.split(". ")
        return [subtask.strip() for subtask in subtasks if subtask.strip()]

    def get_prompt_for_task(self, interpreted_task):
        task_type = interpreted_task['task_type']
        affected_files = ", ".join(interpreted_task['affected_files']) if interpreted_task[
            'affected_files'] else "not specified"

        prompt = f"Task Type: {task_type}\n"
        prompt += f"Affected Files: {affected_files}\n"
        prompt += "Original Description: " + interpreted_task['original_description'] + "\n"
        prompt += "Subtasks:\n"
        for i, subtask in enumerate(interpreted_task['subtasks'], 1):
            prompt += f"{i}. {subtask}\n"

        prompt += "\nBased on this information, please provide a detailed plan to accomplish this task. Include specific code modifications or additions where applicable."

        return prompt







#File ./src/autocoder/test_runner.py:
import subprocess
import os

class TestRunner:
    def __init__(self):
        pass

    def run_tests(self):
        try:
            # Run pytest in the current directory
            result = subprocess.run(['pytest'], capture_output=True, text=True)

            # Check if tests passed
            if result.returncode == 0:
                return True, "All tests passed"
            else:
                # If tests failed, return the error output
                return False, result.stderr

        except Exception as e:
            return False, f"Error running tests: {str(e)}"







#File ./src/autocoder/state.py:
from typing import Annotated, TypedDict
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list, add_messages]
    files: dict
    context: str
    interpreted_task: dict
    modifications: str
    test_results: str







#File ./src/autocoder/code_modifier.py:
import re
import ast
import astor


class CodeModifier:
    def __init__(self):
        pass

    def modify_code(self, original_code, modifications):
        try:
            # Parse the original code into an AST
            tree = ast.parse(original_code)

            # Apply modifications
            modified_tree = self.apply_modifications(tree, modifications)

            # Generate the modified code
            modified_code = astor.to_source(modified_tree)

            return modified_code
        except SyntaxError:
            # If parsing fails, fall back to simple string replacement
            return self.simple_modify(original_code, modifications)

    def apply_modifications(self, tree, modifications):
        # TODO: Implement more sophisticated AST transformations here
        # For now, we'll just add a comment at the top of the file
        new_node = ast.Expr(ast.Str(f"# Modified by AutoCoder: {modifications}"))
        tree.body.insert(0, new_node)
        return tree

    def simple_modify(self, original_code, modifications):
        # Simple string-based modifications
        # This is a fallback method and should be improved
        modified_code = f"# Modified by AutoCoder: {modifications}\n\n{original_code}"

        # Apply simple replacements based on the modifications string
        # This is a very basic implementation and should be enhanced
        replacements = re.findall(r'replace "([^"]*)" with "([^"]*)"', modifications)
        for old, new in replacements:
            modified_code = modified_code.replace(old, new)

        return modified_code







#File ./src/autocoder/nodes/tools/__init__.py:







#File ./src/autocoder/nodes/tools/directory_checker.py:
import os
import logging

logger = logging.getLogger(__name__)


def check_autocoder_dir():
    autocoder_dir = os.path.join(os.getcwd(), ".autocoder")
    project_state_file = os.path.join(autocoder_dir, "project_state.txt")
    return os.path.isdir(autocoder_dir) and os.path.isfile(project_state_file)


def display_init_message():
    message = """
Autocoder isn't initialized in this location. Please run "autocoder init" command for the autocoder to start working on files in this location.

Usage: autocoder [command]
The available commands for execution are listed below.
Commands:
  init          Init autocoder in this directory
  task          Execute a task in an initialized directory
  help          Display help information
"""
    print(message)


def display_usage_message():
    message = """
Usage: autocoder [command]
The available commands for execution are listed below.
Commands:
  init          Init autocoder in this directory
  task          Execute a task in an initialized directory
  help          Display help information
"""
    print(message)


def init_autocoder():
    autocoder_dir = os.path.join(os.getcwd(), ".autocoder")
    project_state_file = os.path.join(autocoder_dir, "project_state.txt")

    if not check_autocoder_dir():
        os.makedirs(autocoder_dir, exist_ok=True)
        with open(project_state_file, 'w') as f:
            f.write('initialized')
        logger.info("Autocoder initialized successfully in this directory with project state 'initialized'.")
        print("Autocoder initialized successfully in this directory with project state 'initialized'.")
    else:
        logger.info("Autocoder is already initialized in this directory.")
        print("Autocoder is already initialized in this directory.")







#File ./src/autocoder/nodes/__init__.py:







#File ./src/autocoder/file_listing/__init__.py:
from .file_listing_node import FileListingNode






#File ./src/autocoder/file_listing/file_listing_node.py:
import os
from pathlib import Path
import logging
import pathspec

logger = logging.getLogger(__name__)

class FileListingNode:
    def __init__(self, project_root, claude_api):
        self.project_root = Path(project_root)
        self.claude_api = claude_api

    def process(self, state):
        try:
            ignore_spec = self.get_ignore_spec()
            project_files = self.list_project_files(ignore_spec)
            state['project_files'] = project_files
            state['excluded_files'] = [str(pat) for pat in ignore_spec.patterns]
            # Build context
            context = self.build_context(project_files)
            state['context'] = context
            logger.info("Context built successfully.")
            return state
        except Exception as e:
            logger.error(f"Error in FileListingNode: {str(e)}")
            state['error'] = str(e)
            return state

    def get_ignore_spec(self):
        patterns = []
        # Read .gitignore
        gitignore_path = self.project_root / '.gitignore'
        if gitignore_path.exists():
            with gitignore_path.open('r') as f:
                gitignore_content = f.read()
            patterns.extend(gitignore_content.splitlines())
            logger.info("Read .gitignore and compiled ignore patterns.")
        else:
            logger.warning(".gitignore file not found.")

        # Add default ignore patterns
        default_ignores = [
            '.git/',
            '.hg/',
            '.svn/',
            '.idea/',
            '*.egg-info/',
            '__pycache__/',
            '.DS_Store',
            '*.pyc',
            '.venv/',
            'env/',
            'build/',
            'dist/',
            'node_modules/',
            '*.log',
            '*.tmp',
        ]
        patterns.extend(default_ignores)
        spec = pathspec.PathSpec.from_lines('gitwildmatch', patterns)
        return spec

    def list_project_files(self, ignore_spec):
        project_files = []
        for root, dirs, files in os.walk(self.project_root):
            # Compute relative paths
            root_relative = os.path.relpath(root, self.project_root)
            if root_relative == '.':
                root_relative = ''
            # Prepare directory paths for matching
            dirs_to_remove = []
            for d in dirs:
                dir_path = os.path.join(root_relative, d)
                if ignore_spec.match_file(dir_path + '/'):
                    dirs_to_remove.append(d)
            for d in dirs_to_remove:
                dirs.remove(d)
            for file in files:
                rel_path = os.path.join(root_relative, file)
                if not ignore_spec.match_file(rel_path):
                    project_files.append(rel_path)
        logger.info(f"Listed project files: {len(project_files)} files found.")
        return project_files

    def build_context(self, project_files):
        context = ''
        for file in project_files:
            file_path = self.project_root / file
            try:
                with file_path.open('r', encoding='utf-8') as f:
                    content = f.read()
                context += f'#File {file}:\n{content}\n\n'
            except Exception as e:
                logger.warning(f"Could not read file {file}: {str(e)}")
        logger.info("Built context from project files.")
        return context







#File ./src/autocoder/__init__.py:
from .autocoder import main

from .file_manager import FileManager
from .context_builder import ContextBuilder
from .task_interpreter import TaskInterpreter
from .code_modifier import CodeModifier
from .test_runner import TestRunner
from .error_handler import ErrorHandler
from .claude_api_wrapper import ClaudeAPIWrapper
from .langgraph_workflow import LangGraphWorkflow
from .state import State
from .file_listing.file_listing_node import FileListingNode

__all__ = [
    'main',
    'FileManager',
    'ContextBuilder',
    'TaskInterpreter',
    'CodeModifier',
    'TestRunner',
    'ErrorHandler',
    'ClaudeAPIWrapper',
    'LangGraphWorkflow',
    'State',
    'FileListingNode'
]







#File ./src/autocoder/autocoder.py:
#!/usr/bin/env python3

import argparse
import logging
import os
from dotenv import load_dotenv

from .file_manager import FileManager
from .context_builder import ContextBuilder
from .task_interpreter import TaskInterpreter
from .code_modifier import CodeModifier
from .test_runner import TestRunner
from .error_handler import ErrorHandler
from .claude_api_wrapper import ClaudeAPIWrapper
from .langgraph_workflow import LangGraphWorkflow
from .nodes.tools.directory_checker import check_autocoder_dir, display_init_message, init_autocoder, \
    display_usage_message
from .file_listing.file_listing_node import FileListingNode

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


def initialize_autocoder():
    logger.info("Starting Autocoder initialization...")
    init_autocoder()
    logger.info("Autocoder directory initialized. Now initializing file listing...")
    result = initialize_file_listing()
    if isinstance(result, dict) and result.get('error'):
        logger.error(f"Autocoder initialization failed: {result['error']}")
        print(f"Error: {result['error']}")
        return False
    logger.info("Autocoder initialization complete.")
    return True


def initialize_file_listing():
    project_root = os.getcwd()
    logger.debug(f"Current working directory: {project_root}")

    # Load environment variables
    load_dotenv()
    api_key = os.getenv('ANTHROPIC_API_KEY') or os.getenv('CLAUDE_API_KEY') or os.getenv('OPENAI_API_KEY')
    if not api_key:
        logger.error("No API key found. Cannot proceed with file listing.")
        return {
            'error': "No API key found. Please set ANTHROPIC_API_KEY or CLAUDE_API_KEY in your environment or .env file."}

    try:
        logger.debug("Initializing Claude API wrapper...")
        claude_api = ClaudeAPIWrapper(api_key)
    except Exception as e:
        logger.error(f"Failed to initialize Claude API: {str(e)}")
        return {'error': f"Failed to initialize Claude API: {str(e)}"}

    logger.info("Creating FileListingNode...")
    file_lister = FileListingNode(project_root, claude_api)

    state = {"project_root": project_root, "claude_api": claude_api}
    logger.info("Processing file listing...")
    updated_state = file_lister.process(state)

    if updated_state.get('error'):
        return updated_state

    logger.info("File listing process completed successfully.")
    return updated_state


def execute_task(task_description):
    if not check_autocoder_dir():
        logger.error("Autocoder is not initialized in this directory.")
        print("Autocoder is not initialized in this directory. Please run 'autocoder init' first.")
        return

    # Load environment variables
    load_dotenv()
    print("Environment variables:", os.environ)

    # Get API key directly from environment
    api_key = os.getenv('ANTHROPIC_API_KEY') or os.getenv('CLAUDE_API_KEY') or os.getenv('OPENAI_API_KEY')
    if not api_key:
        logger.error("No API key found. Cannot proceed with task execution.")
        print(
            "Error: No API key found. Please set ANTHROPIC_API_KEY or CLAUDE_API_KEY in your environment or .env file.")
        return

    try:
        claude_api = ClaudeAPIWrapper(api_key)
    except Exception as e:
        logger.error(f"Failed to initialize Claude API: {str(e)}")
        print(f"Error: Failed to initialize Claude API: {str(e)}")
        return

    # Initialize components
    project_root = os.getcwd()
    file_manager = FileManager(project_root)
    context_builder = ContextBuilder()
    task_interpreter = TaskInterpreter()
    code_modifier = CodeModifier()
    test_runner = TestRunner()
    error_handler = ErrorHandler()

    # Initialize LangGraph workflow
    workflow = LangGraphWorkflow(
        file_manager, context_builder, task_interpreter,
        code_modifier, test_runner, error_handler, claude_api
    )

    # Execute workflow
    result = workflow.execute(task_description)

    print(result)

    # Create debug context if DEBUG mode is enabled
    if file_manager.is_debug_mode():
        file_manager.create_debug_context()


def main():
    parser = argparse.ArgumentParser(description="Claude Automated Coding")
    parser.add_argument("command", nargs='?', default="help", choices=["init", "task", "help"],
                        help="Command to execute")
    parser.add_argument("task_description", nargs='?', default="",
                        help="The task description for the automated coding process")
    args = parser.parse_args()

    logger.debug(f"Received command: {args.command}")

    if args.command == "init":
        logger.info("Initializing Autocoder...")
        if not initialize_autocoder():
            return
    elif args.command == "task":
        if args.task_description:
            logger.info(f"Executing task: {args.task_description}")
            execute_task(args.task_description)
        else:
            logger.error("No task description provided for 'task' command.")
            print("Error: Task description is required for the 'task' command.")
            display_usage_message()
    elif args.command == "help" or not args.command:
        if check_autocoder_dir():
            logger.info("Displaying usage message for initialized directory.")
            display_usage_message()
        else:
            logger.info("Displaying initialization message for uninitialized directory.")
            display_init_message()
    else:
        logger.error(f"Unknown command: {args.command}")
        print(f"Unknown command: {args.command}")
        display_usage_message()


if __name__ == "__main__":
    main()







#File ./src/autocoder/claude_api_wrapper.py:
from anthropic import Anthropic

class ClaudeAPIWrapper:
    def __init__(self, api_key):
        self.client = Anthropic(api_key=api_key)
        self.model = "claude-3-opus-20240229"  # Using the latest Claude 3 model

    def generate_response(self, prompt):
        try:
            message = self.client.messages.create(
                model=self.model,
                max_tokens=1000,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            return message.content[0].text
        except Exception as e:
            print(f"An error occurred: {str(e)}")
            return None

    def format_prompt(self, system_prompt, user_prompt):
        return f"{system_prompt}\n\n{user_prompt}"







#File ./src/autocoder/context_builder.py:
class ContextBuilder:
    def __init__(self):
        self.context = {}

    def build_context(self, file_manager):
        context = file_manager.get_context()
        self.context['built_context'] = context
        return context

    def get_full_context(self):
        return self.context

    def add_context(self, key, value):
        self.context[key] = value

    def get_context(self, key):
        if key in self.context:
            return self.context[key]
        else:
            raise KeyError(f"Key '{key}' not found in context")

    def update_context(self, key, value):
        if key in self.context:
            self.context[key] = value
        else:
            raise KeyError(f"Key '{key}' not found in context")

    def remove_context(self, key):
        if key in self.context:
            del self.context[key]
        else:
            raise KeyError(f"Key '{key}' not found in context")

    def clear_context(self):
        self.context.clear()

    def context_exists(self, key):
        return key in self.context

    def get_size(self):
        return len(self.context)

    def add_multiple_context(self, context_dict):
        self.context.update(context_dict)







#File ./src/autocoder/file_manager.py:
import os
import fnmatch
from typing import List, Dict

class FileManager:
    def __init__(self, project_root: str):
        self.project_root = project_root
        self.project_files: List[str] = []
        self.excluded_files: List[str] = []

    def read_file(self, file_path: str) -> str:
        with open(os.path.join(self.project_root, file_path), 'r') as file:
            return file.read()

    def write_file(self, file_path: str, content: str):
        with open(os.path.join(self.project_root, file_path), 'w') as file:
            file.write(content)

    def load_file_lists(self):
        autocoder_dir = os.path.join(self.project_root, '.autocoder')
        project_files_path = os.path.join(autocoder_dir, 'project_files')
        excluded_files_path = os.path.join(autocoder_dir, 'excluded_files')

        if os.path.exists(project_files_path):
            with open(project_files_path, 'r') as f:
                self.project_files = [line.strip() for line in f if line.strip()]

        if os.path.exists(excluded_files_path):
            with open(excluded_files_path, 'r') as f:
                self.excluded_files = [line.strip() for line in f if line.strip()]

    def get_file_contents(self) -> Dict[str, str]:
        return {file: self.read_file(file) for file in self.project_files}

    def is_debug_mode(self) -> bool:
        return os.getenv('DEBUG', 'false').lower() == 'true'

    def create_debug_context(self):
        if not self.is_debug_mode():
            return

        debug_context = ""
        for file in self.project_files:
            debug_context += f"#File {file}:\n{self.read_file(file)}\n\n"

        debug_context_path = os.path.join(self.project_root, '.autocoder', 'debug_context.txt')
        self.write_file(debug_context_path, debug_context)

    def get_context(self) -> str:
        if self.is_debug_mode():
            debug_context_path = os.path.join(self.project_root, '.autocoder', 'debug_context.txt')
            return self.read_file(debug_context_path)
        else:
            return "\n\n".join([f"#File {file}:\n{self.read_file(file)}" for file in self.project_files])







#File ./src/autocoder/langgraph_workflow.py:
import logging
from typing import Annotated, TypedDict
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langgraph.prebuilt import ToolNode
from langgraph.checkpoint.memory import MemorySaver
from .state import State
from .nodes.tools.directory_checker import check_autocoder_dir

logger = logging.getLogger(__name__)

class LangGraphWorkflow:
    def __init__(self, file_manager, context_builder, task_interpreter,
                 code_modifier, test_runner, error_handler, claude_api):
        self.file_manager = file_manager
        self.context_builder = context_builder
        self.task_interpreter = task_interpreter
        self.code_modifier = code_modifier
        self.test_runner = test_runner
        self.error_handler = error_handler
        self.claude_api = claude_api
        self.graph = self._build_graph()
        self.memory = MemorySaver()

    def _build_graph(self):
        graph = StateGraph(State)

        # Add nodes
        graph.add_node("check_autocoder_dir", check_autocoder_dir)
        graph.add_node("interpret_task", self._interpret_task)
        graph.add_node("build_context", self._build_context)
        graph.add_node("generate_modifications", self._generate_modifications)
        graph.add_node("apply_modifications", self._apply_modifications)
        graph.add_node("run_tests", self._run_tests)

        # Define edges
        graph.add_edge(START, "check_autocoder_dir")
        graph.add_conditional_edges(
            "check_autocoder_dir",
            self._check_initialization,
            {True: "interpret_task", False: END}
        )
        graph.add_edge("interpret_task", "build_context")
        graph.add_edge("build_context", "generate_modifications")
        graph.add_edge("generate_modifications", "apply_modifications")
        graph.add_edge("apply_modifications", "run_tests")
        graph.add_conditional_edges(
            "run_tests",
            self._handle_test_results,
            {True: END, False: "generate_modifications"}
        )

        return graph.compile(checkpointer=self.memory)

    def _check_initialization(self, state):
        return state.get("autocoder_dir_exists", False) and self._check_file_listing_success(state)

    def _check_file_listing_success(self, state):
        return state.get("project_files") is not None and state.get("excluded_files") is not None

    def _interpret_task(self, state: State):
        interpreted_task = self.task_interpreter.interpret_task(state["messages"][-1].content)
        logger.info(f"Task interpreted: {interpreted_task['task_type']}")
        return {"interpreted_task": interpreted_task}

    def _build_context(self, state: State):
        files = self.file_manager.list_files()
        file_contents = {f: self.file_manager.read_file(f) for f in files}
        context = self.context_builder.build_context(file_contents)
        logger.info("Context built successfully")
        return {"files": file_contents, "context": context}

    def _generate_modifications(self, state: State):
        task_prompt = self.task_interpreter.get_prompt_for_task(state["interpreted_task"])
        full_prompt = f"Context:\n{state['context']}\n\nTask:\n{task_prompt}"
        modifications = self.claude_api.generate_response(full_prompt)
        logger.info("Received response from Claude API")
        return {"modifications": modifications}

    def _apply_modifications(self, state: State):
        for file in state["interpreted_task"]["affected_files"]:
            if file in state["files"]:
                original_code = state["files"][file]
                modified_code = self.code_modifier.modify_code(original_code, state["modifications"])
                self.file_manager.write_file(file, modified_code)
                logger.info(f"Modified file: {file}")
        return {}

    def _run_tests(self, state: State):
        success, test_result = self.test_runner.run_tests()
        return {"test_results": test_result}

    def _handle_test_results(self, state: State):
        if "success" in state["test_results"]:
            logger.info("Task completed successfully")
            return True
        else:
            error_report = self.error_handler.handle_error(state["test_results"])
            logger.warning("Tests failed. See error report for details.")
            return False

    def execute(self, task_description, config=None):
        try:
            initial_state = {
                "messages": [("user", task_description)],
                "project_root": self.file_manager.project_root,
                "claude_api": self.claude_api,
                "autocoder_dir_exists": False  # Initialize this in the state
            }
            for event in self.graph.stream(initial_state, config):
                if "messages" in event:
                    print(event["messages"][-1])
            return "Task execution completed."
        except Exception as e:
            error_report = self.error_handler.handle_error(e)
            self.error_handler.log_error(e)
            return error_report







#File ./tests/test_context_builder.py:
import pytest
import os
from autocoder.context_builder import ContextBuilder
from autocoder.file_manager import FileManager


@pytest.fixture
def project_root():
    return os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


@pytest.fixture
def file_manager(project_root):
    return FileManager(project_root)


@pytest.fixture
def context_builder():
    return ContextBuilder()


def test_build_context_with_manifest(context_builder, file_manager):
    context = context_builder.build_context(file_manager)

    print("\nBuild Context Output (Based on MANIFEST.in):")
    print(context)
    print("End of Build Context Output")

    assert "Project Files:" in context

    # Check for some expected files (adjust these based on your project structure)
    assert "File: src/autocoder/context_builder.py" in context
    assert "File: src/autocoder/file_manager.py" in context
    assert "File: src/autocoder/manifest_processor.py" in context

    # Check that the content of files is included
    assert "class ContextBuilder:" in context
    assert "class FileManager:" in context
    assert "class ManifestProcessor:" in context


def test_context_builder_methods(context_builder):
    # Test adding and getting context
    context_builder.add_context("key1", "value1")
    assert context_builder.get_context("key1") == "value1"

    # Test updating context
    context_builder.update_context("key1", "new_value1")
    assert context_builder.get_context("key1") == "new_value1"

    # Test removing context
    context_builder.remove_context("key1")
    with pytest.raises(KeyError):
        context_builder.get_context("key1")

    # Test clearing context
    context_builder.add_context("key2", "value2")
    context_builder.clear_context()
    assert context_builder.get_size() == 0

    # Test context existence
    context_builder.add_context("key3", "value3")
    assert context_builder.context_exists("key3")
    assert not context_builder.context_exists("key4")

    # Test getting size
    assert context_builder.get_size() == 1

    # Test adding multiple context
    context_builder.add_multiple_context({"key4": "value4", "key5": "value5"})
    assert context_builder.get_size() == 3


def test_get_full_context(context_builder):
    context_builder.add_multiple_context({"key1": "value1", "key2": "value2"})
    full_context = context_builder.get_full_context()
    assert full_context == {"key1": "value1", "key2": "value2"}






#File ./tests/test_file_listing_node.py:
import os
import logging
from autocoder.file_listing.file_listing_node import FileListingNode
from autocoder.claude_api_wrapper import ClaudeAPIWrapper

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_file_listing_node():
    project_root = os.getcwd()  # Or specify the path to your project
    api_key = 'your_api_key_here'  # Replace with your actual API key
    claude_api = ClaudeAPIWrapper(api_key)
    file_lister = FileListingNode(project_root, claude_api)

    state = {"project_root": project_root, "claude_api": claude_api}
    updated_state = file_lister.process(state)

    if 'error' in updated_state:
        print(f"Error: {updated_state['error']}")
    else:
        print("Project Files:")
        for file in updated_state['project_files']:
            print(file)
        print("\nContext:")
        print(updated_state['context'][:500])  # Print first 500 characters of context

if __name__ == "__main__":
    test_file_listing_node()







#File ./.env.example:
PROJECT_DIRECTORY=/path/to/your/project
CLAUDE_API_KEY=your_claude_api_key_here
OPENAI_API_KEY=your_openai_api_key_here
DEBUG=true







#File ./files:
./conftest.py
./src/autocoder/error_handler.py
./src/autocoder/task_interpreter.py
./src/autocoder/test_runner.py
./src/autocoder/state.py
./src/autocoder/code_modifier.py
./src/autocoder/nodes/tools/__init__.py
./src/autocoder/nodes/tools/directory_checker.py
./src/autocoder/nodes/__init__.py
./src/autocoder/file_listing/__init__.py
./src/autocoder/file_listing/file_listing_node.py
./src/autocoder/__init__.py
./src/autocoder/autocoder.py
./src/autocoder/claude_api_wrapper.py
./src/autocoder/context_builder.py
./src/autocoder/file_manager.py
./src/autocoder/langgraph_workflow.py
./tests/test_context_builder.py
./tests/test_file_listing_node.py
./.env.example
./files
./requirements.txt







#File ./requirements.txt:
python-dotenv==1.0.1
requests==2.32.3
openai==1.36
anthropic==0.31.2
langgraph==0.1.9
pytest==8.2.2
astor==0.8.1
pathspec==0.12.1







